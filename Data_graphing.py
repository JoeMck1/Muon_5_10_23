import matplotlib.pyplot as plt
import numpy as np
from Data_reader import final_data as data
from Main_GEVP_code import GEVP_eigenvalues

t_max = 14
t_0 = 4
no_bs = 500
no_ops = 5
# op_list = [i for i in range(no_ops)]
op_list = ["$E_0$", "$E_1$", "$E_2$", "$E_3$", "$E_9$"]  # [0, 1, 2, 3, 8]
time = np.arange(t_0, t_max + 1)

data = np.delete(np.delete(data, 4, axis=2), 4, axis=3)  # del op4
data = np.delete(np.delete(data, 4, axis=2), 4, axis=3)  # del op5
data = np.delete(np.delete(data, 4, axis=2), 4, axis=3)  # del op6
data = np.delete(np.delete(data, 4, axis=2), 4, axis=3)  # del op7
data = np.delete(np.delete(data, 4, axis=2), 4, axis=3)  # del op8
data = np.delete(np.delete(data, 4, axis=2), 4, axis=3)  # del op9
data = data[:, :, 0:no_ops, 0:no_ops]

#### plot average eigenvalues against time ####

eigenvalues = GEVP_eigenvalues(data, t_0, no_bs)  # (no_bs, no_ts, 10)

# acquire averages
avg_eigenvalues = np.mean(eigenvalues, axis=0)  # (no_ts, 10)

# acquire errors for errorbars
eigen_errs = np.sqrt(np.var(eigenvalues, axis=0, ddof=1))


# compute effective masses
def eff_mass(configs):
    """This function calculates the effective mass of the given
    configurations. The configurations have shape
    (time-slice, operators)."""

    #### Find the argument that will be passed to the natural
    # logarithm. ####
    log_arg = [configs[i + 1] / configs[i] for i in range(len(configs) - 1)]
    meff = -np.log(np.array(log_arg))

    #### Transpose the output as it is easier to plot
    # (operator, time-slices) array shapes.
    return meff.T


meff = np.array([eff_mass(i) for i in eigenvalues])
#### meff shape = (bs_number, no_ops, no_ts - 1). ####
avg_meff = eff_mass(avg_eigenvalues)

meff_errs = np.sqrt(np.var(meff, axis=0, ddof=1))


A_n = [0.045534599, 0.080828785, 0.099124815, 0.165558276, 0.246081365]
A_n_err = [0.001869416, 0.007092335, 0.014219251, 0.013526121, 0.029465002]
E_n = [0.304569037, 0.389632518, 0.456519184, 0.498086343, 0.553657992]
E_n_err = [0.000637115, 0.001288622, 0.003134271, 0.00377067, 0.008336829]
E_nstar = [1.291393037, 1.22152864, 1.216557391, 1.297487181, 1.351718735]
E_nstar_err = [0.034010074, 0.162420016, 0.194886589, 0.059154977, 0.089656157]


#### Reconstruct maximum and minimum correlators for t = t_0 to
# t = t_max. Where maximum correclator is generated by
# param + param_errs and param - param_errs for minimum. ####
def eigenvalue_fn(A_n, E_n, E_nstar, t_0, corr_tmax):
    """This function reconstructs the eigenvalue function from some
    given fit parameters for a given t0 and correlator tmax. Note this
    tmax is for the correlator only, not the effective mass. A time-
    slice is lost when calculating effective mass."""

    t = np.arange(t_0, corr_tmax + 1)

    return (1 - A_n) * np.exp(-E_n * (t - t_0)) + A_n * np.exp(-E_nstar * (t - t_0))


max_A_n = [A_n[i] + A_n_err[i] for i in range(no_ops)]
max_E_n = [E_n[i] + E_n_err[i] for i in range(no_ops)]
max_E_nstar = [E_nstar[i] + E_nstar_err[i] for i in range(no_ops)]
min_A_n = [A_n[i] - A_n_err[i] for i in range(no_ops)]
min_E_n = [E_n[i] - E_n_err[i] for i in range(no_ops)]
min_E_nstar = [E_nstar[i] - E_nstar_err[i] for i in range(no_ops)]

#### Notice below we have t_max+1. This is because we need to convert
# the effective mass t_max to the correlator t_max. ####
max_corr = [
    eigenvalue_fn(max_A_n[i], max_E_n[i], max_E_nstar[i], t_0, t_max + 1)
    for i in range(no_ops)
]
min_corr = [
    eigenvalue_fn(min_A_n[i], min_E_n[i], min_E_nstar[i], t_0, t_max + 1)
    for i in range(no_ops)
]
max_meff = [eff_mass(i) for i in max_corr]
min_meff = [eff_mass(i) for i in min_corr]

plt.figure()
plt.title("$t_0$=" f"{t_0}")
# plt.title(f"{op_list}" " levels at " r"$t_0=$" f"{t_0}, " r"$t = $" f"{[t_min,t_max]}")
[
    plt.errorbar(
        time,
        avg_meff[j][t_0 : t_max + 1],
        meff_errs[j][t_0 : t_max + 1],
        fmt=".",
        capsize=2,
        label=f"{op_list[j]}",
    )
    for j in range(no_ops)
]
[plt.axhline(y=E_n[i], linewidth=0.5, color="black") for i in range(no_ops)]
# [plt.fill_between(time, min_meff[i], max_meff[i], alpha=0.5) for i in range(no_ops)]
plt.legend(loc="upper right").get_frame().set_alpha(1)
# plt.xticks(np.arange(0, t_max + 1, 5))  ############################################
plt.xlabel(r"$t$")
plt.ylabel(r"$-ln \left( \frac{\lambda(t+1, t_0)}{\lambda(t,t_0)} \right)$")
plt.ylim((0.25, 0.7))
plt.xlim((t_0 - 1, 15))
plt.show()
